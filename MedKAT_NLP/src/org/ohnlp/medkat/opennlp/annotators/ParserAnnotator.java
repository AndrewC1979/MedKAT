/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.ohnlp.medkat.opennlp.annotators;

import java.io.File;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

import opennlp.maxent.io.SuffixSensitiveGISModelReader;
import opennlp.tools.lang.english.HeadRules;
import opennlp.tools.lang.english.ParserChunker;
import opennlp.tools.parser.Parse;
import opennlp.tools.parser.chunking.Parser;
import opennlp.tools.util.Span;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_engine.ResultSpecification;
import org.apache.uima.analysis_engine.annotator.AnnotatorConfigurationException;
import org.apache.uima.analysis_engine.annotator.AnnotatorContext;
import org.apache.uima.analysis_engine.annotator.AnnotatorInitializationException;
import org.apache.uima.analysis_engine.annotator.AnnotatorProcessException;
import org.apache.uima.analysis_engine.annotator.JTextAnnotator_ImplBase;
import org.apache.uima.cas.FSIterator;
import org.apache.uima.cas.Feature;
import org.apache.uima.cas.text.AnnotationIndex;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;
import org.ohnlp.medkat.common.UIMAAnnotationUtils;

/**
 * UIMA Analysis Engine that invokes the OpenNLP Parser. The OpenNLP Parser
 * generates PennTreeBank style syntax tags. These tags are mapped into
 * annotation types according to the tag mapping table (MAPPINGS_PARAM)
 * parameter and corresponding annotations are created in the CAS. The directory
 * containing the various model files used by the OpenNLP Parser must also be
 * specified as a parameter (MODEL_DIR_PARAM).
 * 
 */
public class ParserAnnotator extends JTextAnnotator_ImplBase
{

    /** Parse tag replacements array parameter name. */
    private static final String              PARAM_POSTAGREPLACEMENTS = "POSTagReplacements";

    /** Parse tag mappings array parameter name. */
    private static final String              PARAM_MAPPINGS           = "ParseTagMappings";

    /** Model directory parameter name. */
    private static final String              PARAM_MODELDIR           = "ModelDirectory";

    /** Beam size parameter name. */
    private static final String              PARAM_BEAMSIZE           = "BeamSize";

    /** Advance percentage parameter name. */
    private static final String              PARAM_ADVPERCENT         = "AdvancePercentage";

    private static final String              PARAM_TOKENTYPENAME      = "TokenType";
    private static final String              PARAM_SENTENCETYPENAME   = "SentenceType";
    private static final String              PARAM_POSFEATURENAME     = "POSFeature";

    private String                           m_tokenTypeName;
    private String                           m_sentenceTypeName;
    private String                           m_POSFeatureName;

    /** The MedKAT OpenNLP based parser */
    private MedKATParser                     m_parser;

    /**
     * Hash that maps parse tags to the constructor for the corresponding
     * annotation type class.
     */
    private Map<String, Constructor<?>>      m_parseTagMap              = new Hashtable<String, Constructor<?>>();

    /**
     * maps tags generated by external POS tagger to POS tags supported by this
     * parser
     */
    private Map<String, Map<String, String>> m_posTagReplacements     = new HashMap<String, Map<String, String>>();
    
    
    /**
     * Initialize the Annotator.
     * 
     * @see JTextAnnotator_ImplBase#initialize(UimaContext)
     */
    public void initialize(AnnotatorContext ctx)
    throws AnnotatorInitializationException,
            AnnotatorConfigurationException
    {
        super.initialize(ctx);

        try {
            String[] mappingStrings = (String[])ctx.getConfigParameterValue(PARAM_MAPPINGS);
            if (mappingStrings == null) {
                throw new AnnotatorConfigurationException();
            }
            loadMappings(mappingStrings);

            String[] posTagReplacements = (String[])ctx.getConfigParameterValue(PARAM_POSTAGREPLACEMENTS);
            if (null != posTagReplacements) {
                loadReplacements(posTagReplacements);
            }

            String modelDirName = ctx.getConfigParameterValue(PARAM_MODELDIR).toString();

            File modelDir = new File(modelDirName);
            if (!modelDir.isDirectory()) {
                throw new AnnotatorConfigurationException();
            }

            m_tokenTypeName = ctx.getConfigParameterValue(PARAM_TOKENTYPENAME).toString();
            m_sentenceTypeName = ctx.getConfigParameterValue(PARAM_SENTENCETYPENAME).toString();
            m_POSFeatureName = ctx.getConfigParameterValue(PARAM_POSFEATURENAME).toString();

            // set parameter defaults
            int beamSize = Parser.defaultBeamSize;
            double advancePercentage = Parser.defaultAdvancePercentage;

            Integer beamSizeInt = (Integer)ctx.getConfigParameterValue(PARAM_BEAMSIZE);
            if (beamSizeInt != null) {
                beamSize = beamSizeInt.intValue();
            }
            Float advPercentFlt = (Float)ctx.getConfigParameterValue(PARAM_ADVPERCENT);
            if (advPercentFlt != null) {
                advancePercentage = advPercentFlt.doubleValue();
            }
            
            m_parser = new MedKATParser(new SuffixSensitiveGISModelReader(
                                     new File(modelDirName + "/build.bin.gz")).getModel(),
                                     new SuffixSensitiveGISModelReader(new File(modelDirName + "/check.bin.gz")).getModel(),
                                     new ParserChunker(modelDirName + "/chunk.bin.gz"),
                                     new HeadRules(modelDirName + "/head_rules"),
                                     beamSize,
                                     advancePercentage,
                                     m_posTagReplacements);
        }
        catch (Exception e) {
            throw new AnnotatorInitializationException(e);
        }
    }

    /**
     * Processes the parse tag mappings parameter. The constructor for each
     * class identified in the array is loaded and stored in the mapping
     * hashtable, using the label provided in the parameter as the key.
     * 
     * @param mappingStrings
     *            Array of mapping strings of the form "tag,class"
     * @throws AnnotatorConfigurationException
     */
    private void loadMappings(String[] mappingStrings) throws AnnotatorConfigurationException
    {
        // populate the mappings hash table (key: parse tag,CAS Annotation Type
        // Constructor)
        for (int i = 0; i < mappingStrings.length; i++) {
            String[] mappingPair = mappingStrings[i].split(",");
            if (mappingPair.length < 2) {
                throw new AnnotatorConfigurationException();
            }
            String parseTag = mappingPair[0];
            String className = mappingPair[1];

            Constructor<?> annotationConstructor;
            // get the name of the JCAS type with this name
            Class<?> annotationClass;
            try {
                annotationClass = Class.forName(className);
                // get the constructor for that JCAS type
                annotationConstructor = annotationClass.getConstructor(new Class[] { JCas.class, int.class, int.class });
            }
            catch (Exception e) {
                throw new AnnotatorConfigurationException(e);
            }
            m_parseTagMap.put(parseTag, annotationConstructor);
        }
    }
    
    private void loadReplacements (String[] posTagReplacements)
            throws AnnotatorConfigurationException
    {
        // populate the replacements map (key: external tag,internal tag
        for (int i = 0; i < posTagReplacements.length; i++) {
            String[] replacementTripple = posTagReplacements[i].split(",");
            if (replacementTripple.length != 3) {
                throw new AnnotatorConfigurationException();
            }
            Map<String, String> tok2tag = m_posTagReplacements.get(replacementTripple[0]);
            if (null == tok2tag) {
                tok2tag = new HashMap<String, String>();
                m_posTagReplacements.put(replacementTripple[0], tok2tag);
            }
            tok2tag.put(replacementTripple[1], replacementTripple[2]);
        }
    }
    

    /**
     * Process a CAS.
     * 
     * @see JTextAnnotator_ImplBase#process(JCas)
     */
    public void process (JCas jcas, ResultSpecification rs) throws AnnotatorProcessException
    {
        try {
            Class<? extends Annotation> tokenClass = UIMAAnnotationUtils.forName(m_tokenTypeName);
            Feature posFeature = jcas.getTypeSystem().getType(m_tokenTypeName).getFeatureByBaseName(m_POSFeatureName);
    
            AnnotationIndex sentenceIndex = jcas.getAnnotationIndex(UIMAAnnotationUtils.getTypeIndexId(m_sentenceTypeName));
            AnnotationIndex tokenIndex = jcas.getAnnotationIndex(UIMAAnnotationUtils.getTypeIndexId(m_tokenTypeName));
    
            // iterate over Sentences
            for (FSIterator sentenceIterator = sentenceIndex.iterator(); sentenceIterator.hasNext();) {
                Annotation sentence = (Annotation)sentenceIterator.next();
    //            System.err.printf("%s: %d|%d\n", 
    //                    sentence.getClass().getName(), sentence.getBegin(), sentence.getEnd());
                String sentenceText = sentence.getCoveredText();
    
                // iterate over Tokens
                Parse sentenceParse = new Parse(sentenceText, new Span(0, sentenceText.length()), "INC", 1, null);
    
                for (FSIterator tokenIterator = tokenIndex.subiterator(sentence); tokenIterator.hasNext();) {
                    Annotation token = (Annotation)tokenIterator.next();
    //                System.err.printf("\t%s: %d|%d\n", 
    //                        token.getClass().getName(), token.getBegin(), token.getEnd());
                    Parse tokenParse = new Parse(sentenceText,
                                                 new Span(token.getBegin() - sentence.getBegin(), token.getEnd() - sentence.getBegin()),
                                                 Parser.TOK_NODE,
                                                 0, 0);
                    sentenceParse.insert(tokenParse);
                }
                // printParse(sentenceParse, "");
                
                sentenceParse = m_parser.parse(jcas, sentence.getBegin(), sentenceParse, tokenClass, posFeature);
    
                makeAnnotations(sentenceParse, jcas, sentence.getBegin(), "\t\t");
            }
        }
        catch (Exception e) {
            throw new AnnotatorProcessException(e);
        }
    }

    /**
     * Create the parse annotations in the CAS corresponding to the results of
     * the OpenNLP parse.
     * 
     * @param parse * The parse generated by the OpenNLP parser.
     * @param jCas  * The JCas in which to create the annotations.
     * @throws AnnotatorProcessException
     */
    private boolean makeAnnotations (Parse parse, JCas jcas, int start, String indent) throws AnnotatorProcessException
    {
        boolean ann_created = false;
        Span span = parse.getSpan();
        String tag = parse.getType();
        if ((null != tag) && !tag.equals(Parser.TOK_NODE)) {

            Parse[] children = parse.getChildren();
            for (int i = 0; i < children.length; i++) {
                if (makeAnnotations(children[i], jcas, start, indent + "\t")) {
                    ann_created = true;
                }
            }
            // make the annotation
            if (!ann_created) {
                Constructor<?> annotationMaker = m_parseTagMap.get(tag);
                if (null != annotationMaker) {
                    try {
                        Annotation ann = (Annotation)annotationMaker.newInstance(new Object[]{jcas, start + span.getStart(), start + span.getEnd()});
                        ann.addToIndexes();
//                        System.err.printf("%s%s: %d|%d\n", indent,
//                                ann.getClass().getName(), ann.getBegin(), ann.getEnd());
                        return true;
                    }
                    catch (Exception e) {
                        throw new AnnotatorProcessException(e);
                    }
                }
            }
        }
        return ann_created;
    }

    public String show (Parse parse)
    {
        Span span = parse.getSpan();
        if (parse.getType().equals(Parser.TOK_NODE)) {
            return (parse.getText().substring(span.getStart(), span.getEnd()));
        }
        Parse[] children = parse.getChildren();
        if (children.length == 1) {
            Parse childParse = children[0];
            if (childParse.getType().equals(Parser.TOK_NODE)) {
                return (show(childParse) + "/" + parse.getType());
            }
        }
        String retVal = "(" + parse.getType() + " ";
        for (int i = 0; i < children.length; i++) {
            retVal += show(children[i]) + " ";
        }
        return (retVal + ")");
    }

    public void printParse (Parse parse, String prefix)
    {
        System.out.println(prefix + "Label: " + parse.getLabel());
        System.out.println(prefix + "Type: " + parse.getType());
        Span span = parse.getSpan();
        System.out.println(prefix + "Span: " + span.getStart() + ":"
                           + span.getEnd());
        System.out.println(prefix
                           + "Text: "
                           + parse.getText().substring(span.getStart(),
                                   span.getEnd()));
        Parse[] children = parse.getChildren();
        for (int i = 0; i < children.length; i++) {
            printParse(children[i], prefix + "  ");
        }

    }

}
